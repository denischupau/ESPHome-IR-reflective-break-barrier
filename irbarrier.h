/*                                                                                                                                                                                                                 
 * Wifi IoT that creates a barrier using a blinking IR beam coupled with an IR remote sensor (from an old TV set) on the same side of the barrier, and a reflector the other side of the barrier in front of them, 
so there is no need to have a cable between the 2 sides of the barrier.                                                                                                                                            
 * The IoT barrier (beam-breaking IoT) is running ESPHome on an ESP-01 1MB, (ESP8266).                                                                                                                             
 * It generates a 38kHz carrier for an IR emitter (IR LED driven by a transistor) via the GPIO3 (RX) pin.                                                                                                          
 * The 38kHz square wave is accurately generated by outputing a 0xAAAAAAAAAAAAAAAA pattern via the I2S peripheral (DMA driven).                                                                                    
 * This 38kHz carrier is blinking at a rate of 30-70Hz to avoid the IR sensor (here HS0038 or other) after a while                                                                                                 
 *  ignoring the constant presence of the carrier: the carrier can NOT be continuously running to use this sensor.                                                                                                 
 *                                        
 * The builtin blue LED (LED_BUILTIN) of the ESP-01 goes ON when the barrier is broken, and is OFF when the barrier is working fine without obstacle. That facilitates the aiming and placement!                   
 * I tried this setup with a distance between 30cm - 5m.                                                 
 *
 * I used built the circuit in the included image.
 *                                                                                                       
 * The problem I had:                        
 *   - close to the IR emitter (30-50cm), more or less all materials are reflective and the barrier is never broken.                                                                                               
 *   - every now and then the IoT goes "unavailable", that doesn't seem to influence the fiability of this IoT.                                                                                                    
 * I encourage to play with the timings: Blink_ON/OFF, BEAM_MAX_INTERRUPT_LENGTH_MILLIS. DEBOUNCE_MILLIS.                                                                                                          
 *                                     
 * The ESP8266 pins for I2S are:        
 * Data bits (SD) = GPIO3/RX0     (directly accessible on the ESP-01)                                    
 * Data bit-clock (SCK) = GPIO15  (NOT directly accessible on the ESP-01's)                              
 * Word select (WS) = GPIO2/TX1   (directly accessible, though not used here)                            
 *                            
 * Resources and inspiration, thanks to them all for their work:                                                                                                                                                   
 *   https://shepherdingelectrons.blogspot.com/2018/10/the-ir-egg-voice-controlled-esp8266-i2s.html      
 *   https://github.com/roberttidey/espI2sClockGen                                                       
 *   https://www.instructables.com/Esp8266-Clock-and-Pulse-Generator/                                    
 *   https://espenandersen.no/light-barrier/
 *   https://www.electroschematics.com/infrared-light-barrier/                                           
 *   https://www.hackster.io/mova2/long-range-beam-break-sensor-with-reflector-panel-4dfc48              
 *                                           
 * The blinking that works well in my tests is BLINK_OFF is 2xBLINK_ON, with BLINK_ON_MILLIS around 6 to 20ms.                                                                                                     
 * For some values of "blinking" it works well for a while (15-30min) then the sensor begins to ignore the IR carrier signals.                                                                                     
 * I tried to program it with a custom FreeRTOS MQTT solution to see if it's better: the SDK is so old that nothing compiles (Python 2.4, GCC 11, etc.) is too time consuming to debug.                            
 * I also tried to program it with the Arduino SDK (MQTT IoT), but I couldn't find a way to execute the "loop()" or "Ticker" functions at a 2-20ms period.                                                         
 * Another really good solution is use a microcontroller with hoardware PWM (i.e. ATTiny) to generate the carrier with the arduino function "tone(38000);".
 * Or as in a few of the resources: 2 NE555 to generate the blinking 38kHz (38,461Hz).                                                                                                                             
 *                  
 *                           
 * Put those 3 files (this one, and the 2 i2sTXcircular.* in an "irbarrier01" folder) in your ESPHome config folder (usually where your YAML file is).                                                             
 *                              
 * In the YAML file for this ESPHome ESP01 device, add:                                                  
 * esphome:                                                                                              
 *   name: irbarrier01                                                                                                                                                                                             
 *   friendly_name: IRbarrier01                                                                          
 *   includes:                                                                                           
 *   - irbarrier01/                                                                                                                                                                                                
 *                                                                                                       
 * binary_sensor:                                                                                                                                                                                                  
 *   - platform: custom         
 *     lambda: |-         
 *       auto irbarrier = new MyIRBarrier();                                                             
 *       App.register_component(irbarrier);                                                              
 *       return {irbarrier};                   
 *                                 
 *     binary_sensors:               
 *       name: "IR Barrier"          
 */                                                                                                      
                                                    
#include "esphome.h"                  
#include "i2sTXcircular.h"     
                                                    
// PIN attribution
#define IR_INT        0                                                                                                                                                                                            
#define IR_LED        3           
#define RED_LED       LED_BUILTIN                                                                        
#define BLINK_ON_MILLIS    12                                                                            
#define BLINK_OFF_MILLIS   24                                                                            
#define BEAM_MAX_INTERRUPT_LENGTH_MILLIS 120
#define DEBOUNCE_MILLIS    500                    
                                                    
// Global variables & functions       
volatile bool irChange = false;  //       
// IR signal recieving (runs on interrupt, see in the class)                                             
IRAM_ATTR void IR_ISR() {                                                                                
  if (!irChange)
    irChange = true;
}        

// ESPHome's custom component                                                                                                                                                                                      
class MyIRBarrier : public PollingComponent, public BinarySensor {                                                                                                                                                 
  private:                                                                                                                                                                                                         
    bool beam_last_state = true;                                                                                                                                                                                   
    bool beam_current_state = true;                                                                                                                                                                                
    bool ir_carrier_on = false;                                                                                                                                                                                    
    bool state_on_registered = false;                                                                                                                                                                              
    bool state_off_registered = false;                                                                                                                                                                             
    long blink_last_millis = 0;                                                                                                                                                                                    
    long beam_last_blink_millis = 0;                                                                                                                                                                               
    long debounce_last_millis = 0;                                                                                                                                                                                 
    long current_millis = 0;                                                                                                                                                                                       
                                                                                                                                                                                                                   
  public:                                                                                                                                                                                                          
    // constructor                                                                                                                                                                                                 
    MyIRBarrier() : PollingComponent(2) {                                                                                                                                                                          
    }                                                                                                                                                                                                              
                                                                                                                                                                                                                   
    void setup() override {                                                                                                                                                                                        
      // This will be called by App.setup()                                                                                                                                                                        
      pinMode(IR_INT, INPUT_PULLUP);                                                                                                                                                                               
      attachInterrupt(IR_INT, IR_ISR, FALLING);                                                                                                                                                                    
      pinMode(RED_LED, OUTPUT);                                                                                                                                                                                    
      digitalWrite(RED_LED, 0);                                                                                                                                                                                    
      i2scInit(1024, 40, 52, 0, 0);   // 160,000,000 Hz / 40 / 52 / 32 bits x 16 periods per 32 bits = 38,461 Hz                                                                                                   
      i2scSetMSArrayItem(0, 1, 1, 0); // 1 bits HIGH, 1 bit LOW so we have a low I2S clock and less interrupts.                                                                                                    
      i2scBegin();                                                                                                                                                                                                 
      ir_carrier_on = true;                                                                                                                                                                                        
    }                                                                                                                                                                                                              
                                                                                                                                                                                                                   
    void update() override {                                                                                                                                                                                       
      // This will be called every "update_interval" milliseconds.                                                                                                                                                 
      // Pulse of modulated IR light detected: reset last beam blink time, beam blinking (i.e. present / uninterrupted)                                                                                            
      // Impulsion received (irChange): reset timer, beam is present                                                                                                                                               
      if (irChange) {                                                                                                                                                                                              
        irChange = false;                                                                                                                                                                                          
        beam_last_blink_millis = millis();
        beam_current_state = true;                                                                                                                                                                                 
      }                                                                                                  
                                                    
      // send a message when beam state changed   
      if (beam_current_state != beam_last_state) {                                                       
        beam_last_state = beam_current_state;
        if (beam_current_state) {                                                                                                                                                                                  
          digitalWrite(RED_LED, 1);                                                                                                                                                                                
          state_on_registered = true;                                                                                                                                                                              
        } else {                       
          digitalWrite(RED_LED, 0);     
          state_off_registered = true;                                                                   
        }                                                                                                
      }                                                                                                  
                                                    
      // Introducing a "debounce" option to avoid sending too many state changes: send state changes after DEBOUNCE_MILLIS                                                                                         
      current_millis = millis();                                                                         
      if (current_millis - debounce_last_millis > DEBOUNCE_MILLIS) {                                     
        if (state_off_registered){     // priority to OFF state because ON is default                    
          state_off_registered = false;     
          publish_state(false);                                                                          
          debounce_last_millis = current_millis;                                                         
        } else {                             
          if (state_on_registered) {                                                                                                                                                                               
            state_on_registered = false;                                                                                                                                                                           
            publish_state(true);                                                                                                                                                                                   
            debounce_last_millis = current_millis;                                                                                                                                                                 
          }                                                                                                                                                                                                        
        }                                                                                                                                                                                                          
      }             
                                                    
      // If no modulated IR pulse detected since more than N milliseconds: Beam interruption detected                                                                                                              
      current_millis = millis();
      if (current_millis - beam_last_blink_millis > BEAM_MAX_INTERRUPT_LENGTH_MILLIS) {                  
        beam_current_state = false;                                                                      
      }                                                                                                                                                                                                            
                                                                                                         
      // turn on and off the modulated IR signal every N millisecond (>100Hz)                            
      // Because most infrared sensors do not respond very well to continuous incidence of infrared light.                                                                                                         
      // Switching the IR source off, even for a small period, allows IR detectors to ‘recuperate’,      
      // and so optimise their ability to minimize the response to ambient light (https://www.electroschematics.com/infrared-light-barrier/)                                                                       
      current_millis = millis();
      if (ir_carrier_on) {
        if ((current_millis - blink_last_millis) >= BLINK_ON_MILLIS) {                                   
          blink_last_millis = current_millis;                                                            
          i2scEnd();                           
          ir_carrier_on = false;   
        }                            
      } else {                       
        if ((current_millis - blink_last_millis) >= BLINK_OFF_MILLIS) {                                  
          blink_last_millis = current_millis;       
          i2scBegin();                
          ir_carrier_on = true;
        }                                           
      }           
                                                                                                                                                                                                                   
    }
};
