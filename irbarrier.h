/* License: GNU GPLv3.
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
 *
 * *****
 * 
 * Copyright @ 2019 Denis Chupau. All rights reserved.
 * 
 * *****
 *
 * Wifi IoT that creates a barrier using a blinking IR beam coupled with an IR remote sensor both on the same side of the barrier,
 * a reflector is on the other side of the barrier in front of them, so there is no need to have a cable running between the 2 sides of the barrier.
 *
 * The IoT barrier (beam-breaking IoT) is running ESPHome on an ESP-01 1MB, (ESP8266) with custom code (this one!).
 * It generates a 38kHz carrier for an IR emitter (IR LED driven by a transistor) via the GPIO3 (RX) pin.
 * The 38kHz square wave is accurately generated by outputing a 0xAAAAAAAAAAAAAAAA pattern via the I2S peripheral (DMA driven).
 * This 38kHz carrier is blinking at a rate of 30-70Hz.
 *
 * I encourage to play with the timings: Blink_ON/OFF, BEAM_MAX_INTERRUPT_LENGTH_MILLIS. DEBOUNCE_MILLIS.                                                                                                          
 *
 * The ESP8266 pins for I2S are:        
 * Data bits (SD) = GPIO3/RX0     (directly accessible on the ESP-01)                                    
 * Data bit-clock (SCK) = GPIO15  (NOT directly accessible on the ESP-01's)                              
 * Word select (WS) = GPIO2/TX1   (directly accessible, though not used here)                            
 *                            
 *                                           
 * The blinking that works well in my tests is BLINK_OFF at 2xBLINK_ON, with BLINK_ON_MILLIS around 6 to 20ms.                                                                                                     
 * For some values of "blinking" it works well for a while (15-30min) then the sensor begins to ignore the IR carrier signals.
 *
 */

#include "esphome.h"
#include "i2sTXcircular.h"

// PIN attribution
#define IR_INT        0
#define IR_LED        3
#define RED_LED       LED_BUILTIN
#define BLINK_ON_MILLIS    12
#define BLINK_OFF_MILLIS   24
#define BEAM_MAX_INTERRUPT_LENGTH_MILLIS 120
#define DEBOUNCE_MILLIS    500

// Global variables & functions
volatile bool irChange = false;  // variable that tracks the changes on the interrupt pin (IR sensor pin)

// IR signal recieving (runs on interrupt, see in the class)
IRAM_ATTR void IR_ISR() {
  if (!irChange)
    irChange = true;
}

// ESPHome's custom component
class MyIRBarrier : public PollingComponent, public BinarySensor {
  private:
    bool beam_last_state = true;
    bool beam_current_state = true;
    bool ir_carrier_on = false;
    bool state_on_registered = false;
    bool state_off_registered = false;
    long blink_last_millis = 0;
    long beam_last_blink_millis = 0;
    long debounce_last_millis = 0;
    long current_millis = 0;

  public:
    // constructor
    MyIRBarrier() : PollingComponent(2) {
    }

    void setup() override {
      // This will be called by App.setup()
      pinMode(IR_INT, INPUT_PULLUP);
      attachInterrupt(IR_INT, IR_ISR, FALLING);
      pinMode(RED_LED, OUTPUT);
      digitalWrite(RED_LED, 0);
      i2scInit(1024, 40, 52, 0, 0);   // 160,000,000 Hz / 40 / 52 / 32 bits x 16 periods per 32 bits = 38,461 Hz
      i2scSetMSArrayItem(0, 1, 1, 0); // 1 bits HIGH, 1 bit LOW so we have a low I2S clock and less interrupts.
      i2scBegin();
      ir_carrier_on = true;
    }

    void update() override {
      // This will be called every "update_interval" milliseconds.
      // Pulse of modulated IR light detected: reset last beam blink time, beam blinking (i.e. present / uninterrupted)
      // Impulsion received (irChange): reset timer, beam is present
      if (irChange) {
        irChange = false;
        beam_last_blink_millis = millis();
        beam_current_state = true;
      }

      // register if beam state changed
      if (beam_current_state != beam_last_state) {
        beam_last_state = beam_current_state;
        if (beam_current_state) {
          digitalWrite(RED_LED, 1);
          state_on_registered = true;
        } else {
          digitalWrite(RED_LED, 0);
          state_off_registered = true;
        }
      }

      // Introducing a "debounce" option to avoid sending too many state changes: publish state changes only after DEBOUNCE_MILLIS
      current_millis = millis();
      if (current_millis - debounce_last_millis > DEBOUNCE_MILLIS) {
        if (state_off_registered){     // priority to OFF state because ON is default
          state_off_registered = false;
          publish_state(false);
          debounce_last_millis = current_millis;
        } else {
          if (state_on_registered) {
            state_on_registered = false;
            publish_state(true);
            debounce_last_millis = current_millis;
          }
        }
      }

      // If no modulated IR pulse detected since more than N milliseconds: Beam interruption detected
      current_millis = millis();
      if (current_millis - beam_last_blink_millis > BEAM_MAX_INTERRUPT_LENGTH_MILLIS) {
        beam_current_state = false;
      }

      // turn on and off the modulated IR signal every N millisecond
      current_millis = millis();
      if (ir_carrier_on) {
        if ((current_millis - blink_last_millis) >= BLINK_ON_MILLIS) {
          blink_last_millis = current_millis;
          i2scEnd();
          ir_carrier_on = false;
        }
      } else {
        if ((current_millis - blink_last_millis) >= BLINK_OFF_MILLIS) {
          blink_last_millis = current_millis;
          i2scBegin();
          ir_carrier_on = true;
        }
      }
    }
};
